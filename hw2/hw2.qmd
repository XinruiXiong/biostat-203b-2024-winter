---
title: "Biostat 203B Homework 2"
subtitle: Due Feb 9 @ 11:59PM
author: "Xinrui Xiong 806329308 "
knitr:
  opts_chunk: 
    cache: false    
    echo: true
    fig.align: 'center'
    fig.width: 6
    fig.height: 4
    message: FALSE
execute:
  eval: false    
---

Display machine information for reproducibility:

```{r,eval=T}

sessionInfo()
```

Load necessary libraries (you can add more as needed).

```{r setup}
library(arrow)
library(data.table)
library(memuse)
library(pryr)
library(R.utils)
library(tidyverse)
```

Display memory information of your computer

```{r}
memuse::Sys.meminfo()
```

In this exercise, we explore various tools for ingesting the [MIMIC-IV](https://mimic.mit.edu/docs/iv/) data introduced in [homework 1](https://ucla-biostat-203b.github.io/2024winter/hw/hw1/hw1.html).

Display the contents of MIMIC `hosp` and `icu` data folders:

```{bash}
ls -l ~/mimic/hosp/
```

```{bash}
ls -l ~/mimic/icu/
```

## Q1. `read.csv` (base R) vs `read_csv` (tidyverse) vs `fread` (data.table)

### Q1.1 Speed, memory, and data types

There are quite a few utilities in R for reading plain text data files. Let us test the speed of reading a moderate sized compressed csv file, `admissions.csv.gz`, by three functions: `read.csv` in base R, `read_csv` in tidyverse, and `fread` in the data.table package.

Which function is fastest? Is there difference in the (default) parsed data types? How much memory does each resultant dataframe or tibble use? (Hint: `system.time` measures run times; `pryr::object_size` measures memory usage.)

```{r,eval=T}
library(tidyverse)
library(data.table)
library(pryr)
time1<-system.time({
  csv_read1<-read.csv("/Users/xinrui/mimic/hosp/admissions.csv.gz")
})
time2<-system.time({
  csv_read2<-read_csv("/Users/xinrui/mimic/hosp/admissions.csv.gz")
})

time3<-system.time({
  csv_read3<-fread("/Users/xinrui/mimic/hosp/admissions.csv.gz")
})

class1<-class(csv_read1)
class2<-class(csv_read2)
class3<-class(csv_read3)

size1<-object_size(csv_read1)
size2<-object_size(csv_read2)
size3<-object_size(csv_read3)

print("read.csv:")
class1
time1
size1

print("read_csv:")
class2
time2
size2

print("fread:")
class3
time3
size3

rm(csv_read1)
rm(csv_read3)
```

As we can see, the data types are different, read.csv() generate a "data.frame" data, read_csv generate a "spec_tbl_df" data, and fread() generate a "data.table" data.

The running time also differs, fread() is the fastest, and read.csv() is the slowest.

fread() generate the smallest dataset of 50.13MB, while read.csv() generate the largest dataset of 158.71MB, and read_csv generate a 55.31MB dataset.

### Q1.2 User-supplied data types

Re-ingest `admissions.csv.gz` by indicating appropriate column data types in `read_csv`. Does the run time change? How much memory does the result tibble use? (Hint: `col_types` argument in `read_csv`.)

```{r, eval=T}
# To get the types of each columns
str(csv_read2)
rm(csv_read2)

time4<-system.time({
# "POSIXct" type is not able to set by "col_types=", using chr instead
csv_read4<-read_csv("/Users/xinrui/mimic/hosp/admissions.csv.gz",col_types=c("d","i","","","",'c','c','c','c','c','c','c','c',"","",'i'))})
size4<-object_size(csv_read4)
time4
size4

rm(csv_read4)
```

By indicating some columns' types, we can see the running time decreases very slightly. And the size doesn't change, still 55.31MB.

## Q2. Ingest big data files

<p align="center">

<img src="./bigfile.png" width="50%"/>

</p>

Let us focus on a bigger file, `labevents.csv.gz`, which is about 125x bigger than `admissions.csv.gz`.

```{bash}
ls -l ~/mimic/hosp/labevents.csv.gz
```

Display the first 10 lines of this file.

```{bash}
gzcat < ~/mimic/hosp/labevents.csv.gz | head -10
```

### Q2.1 Ingest `labevents.csv.gz` by `read_csv`

<p align="center">

<img src="./readr_logo.png" width="20%"/>

</p>

Try to ingest `labevents.csv.gz` using `read_csv`. What happens? If it takes more than 5 minutes on your computer, then abort the program and report your findings.

```{r,eval=TRUE}
# read_csv("~/mimic/hosp/labevents.csv.gz")
```

In my computer, it didn't finish reading after 5 minutes. Obviously it is very inefficient to use read_csv() to read very large data.

### Q2.2 Ingest selected columns of `labevents.csv.gz` by `read_csv`

Try to ingest only columns `subject_id`, `itemid`, `charttime`, and `valuenum` in `labevents.csv.gz` using `read_csv`. Does this solve the ingestion issue? (Hint: `col_select` argument in `read_csv`.)

```{r,eval=F}
csv_read5<-read_csv("~/mimic/hosp/labevents.csv.gz",col_select = c("subject_id", "itemid", "charttime", "valuenum"))
rm(csv_read5)
```

Yes, this time read_csv() read the selected columns successfully, though takes a relatively long time.

### Q2.3 Ingest subset of `labevents.csv.gz`

<p align="center">

<img src="./linux_logo.png" width="20%"/>

</p>

Our first strategy to handle this big data file is to make a subset of the `labevents` data. Read the [MIMIC documentation](https://mimic.mit.edu/docs/iv/modules/hosp/labevents/) for the content in data file `labevents.csv`.

In later exercises, we will only be interested in the following lab items: creatinine (50912), potassium (50971), sodium (50983), chloride (50902), bicarbonate (50882), hematocrit (51221), white blood cell count (51301), and glucose (50931) and the following columns: `subject_id`, `itemid`, `charttime`, `valuenum`. Write a Bash command to extract these columns and rows from `labevents.csv.gz` and save the result to a new file `labevents_filtered.csv.gz` in the current working directory. (Hint: use `zcat <` to pipe the output of `labevents.csv.gz` to `awk` and then to `gzip` to compress the output. To save render time, put `#| eval: false` at the beginning of this code chunk.)

Display the first 10 lines of the new file `labevents_filtered.csv.gz`. How many lines are in this new file? How long does it take `read_csv` to ingest `labevents_filtered.csv.gz`?

```{bash, eval=F}
cd ~/mimic/hosp/
gzcat labevents.csv.gz |awk -F ',' '
    BEGIN {OFS=","}
    NR == 1 {
        for (i=1; i<=NF; i++) {
            if ($i == "subject_id") subject_id_col = i
            else if ($i == "itemid") itemid_col = i
            else if ($i == "charttime") charttime_col = i
            else if ($i == "valuenum") valuenum_col = i
        }
    }
    NR > 1 && ($itemid_col==50912 || $itemid_col==50971 || $itemid_col==50983 || $itemid_col==50902 || $itemid_col==50882 || $itemid_col==51221 || $itemid_col==51301 || $itemid_col==50931) {
        print $subject_id_col, $itemid_col, $charttime_col, $valuenum_col
    }
' | gzip > labevents_filtered.csv.gz
```

```{bash,eval =T}
gzcat ~/mimic/hosp/labevents_filtered.csv.gz|head -n 10 
gzcat ~/mimic/hosp/labevents_filtered.csv.gz|wc -l 
```

```{r,eval=T}
system.time({
  csv_read_temp<-read_csv("~/mimic/hosp/labevents_filtered.csv.gz")
})
rm(csv_read_temp)
```

As shown above, there are 24855909 rows in labevents_filtered.csv.gz, and the running time is shown above.

### Q2.4 Ingest `labevents.csv` by Apache Arrow

<p align="center">

<img src="./arrow_logo.png" width="30%"/>

</p>

Our second strategy is to use [Apache Arrow](https://arrow.apache.org/) for larger-than-memory data analytics. Unfortunately Arrow does not work with gz files directly. First decompress `labevents.csv.gz` to `labevents.csv` and put it in the current working directory. To save render time, put `#| eval: false` at the beginning of this code chunk.

Then use [`arrow::open_dataset`](https://arrow.apache.org/docs/r/reference/open_dataset.html) to ingest `labevents.csv`, select columns, and filter `itemid` as in Q2.3. How long does the ingest+select+filter process take? Display the number of rows and the first 10 rows of the result tibble, and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)

Write a few sentences to explain what is Apache Arrow. Imagine you want to explain it to a layman in an elevator.

```{bash, eval=F}
cd ~/mimic/hosp/
gzcat labevents.csv.gz > labevents.csv
```

```{r,eval=T}
library(arrow)
system.time({
csv_read6<-open_dataset("~/mimic/hosp/labevents.csv", format="csv")
filtered_csv_read6<-csv_read6%>%
  filter(itemid %in% c(50912, 50971, 50983, 50902, 50882, 51221, 51301, 50931)) %>%
  select(subject_id, itemid, charttime, valuenum)
})
# rm(csv_read6)
filtered_csv_read6<-data.frame(filtered_csv_read6)
nrow(filtered_csv_read6)
head(filtered_csv_read6,10)


rm(filtered_csv_read6)


```

The running time is shown above.

Apache Arrow is a very efficient data type that helps computers in different platforms read, transmit, and exchange the data smoothly. It makes data (especially very large data) sharing faster and more efficient.

### Q2.5 Compress `labevents.csv` to Parquet format and ingest/select/filter

<p align="center">

<img src="./parquet_logo.png" width="30%"/>

</p>

Re-write the csv file `labevents.csv` in the binary Parquet format (Hint: [`arrow::write_dataset`](https://arrow.apache.org/docs/r/reference/write_dataset.html).) How large is the Parquet file(s)? How long does the ingest+select+filter process of the Parquet file(s) take? Display the number of rows and the first 10 rows of the result tibble and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)

Write a few sentences to explain what is the Parquet format. Imagine you want to explain it to a layman in an elevator.

```{r,eval=F}
write_dataset(csv_read6,"~/mimic/hosp/labevents.parquet")
rm(csv_read6)
```

```{r,eval=T}
file_size <-file.info("~/mimic/hosp/labevents.parquet/part-0.parquet")$size

file_size_formatted <- format(file_size / 1e9, digits = 2) 

cat("File size:", file_size_formatted, "GB", "\n")
```

The Parquet file is 2.1GB.

```{r, eval=F}
# the data is extremely large, and rendering this part will cause
# vector memory exhausted, so I set eval=F
system.time({
csv_read7<-read_parquet("~/mimic/hosp/labevents.parquet/part-0.parquet")
filtered_csv_read7<-csv_read7%>%
  filter(itemid %in% c(50912, 50971, 50983, 50902, 50882, 51221, 51301, 50931)) %>%
  select(subject_id, itemid, charttime, valuenum)
})

nrow(filtered_csv_read7)
head(filtered_csv_read7,10)

rm(filtered_csv_read7)

```

The data is extremely large and rendering it will cause vector memory exhausted, so I set "eval=F" in this part. The code is working.

Parquet format is like a efficient data format for storage. Parquet keeps similar kinds of data together, making it really fast to find the needed information while taking less space to store.

### Q2.6 DuckDB

<p align="center">

<img src="./duckdb_logo.png" width="20%"/>

</p>

Ingest the Parquet file, convert it to a DuckDB table by [`arrow::to_duckdb`](https://arrow.apache.org/docs/r/reference/to_duckdb.html), select columns, and filter rows as in Q2.5. How long does the ingest+convert+select+filter process take? Display the number of rows and the first 10 rows of the result tibble and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)

Write a few sentences to explain what is DuckDB. Imagine you want to explain it to a layman in an elevator.

```{r,eval=F}
library(duckdb)

con <- dbConnect(duckdb::duckdb())
system.time({
  csv_read8<-read_parquet("~/mimic/hosp/labevents.parquet/part-0.parquet")
  filtered_csv_read8<-csv_read8%>%
  filter(itemid %in% c(50912, 50971, 50983, 50902, 50882, 51221, 51301, 50931)) %>%
  select(subject_id, itemid, charttime, valuenum)
  rm(csv_read8)
  to_duckdb(filtered_csv_read8,con,"mytable")
})

query1 <- "SELECT COUNT(*) FROM mytable"
result1 <- dbGetQuery(con, query1)
row_count <- as.numeric(result[1, 1])
print(row_count)


query2 <- "SELECT * FROM mytable LIMIT 10"
result2 <- dbGetQuery(con, query2)
print(result2)

rm(filtered_csv_read8)
dbDisconnect(con)

```

The code are working, but will have vector memory exhausted if rendering.

DuckDB is a special kind of database that's designed to handle large amounts of data really quickly, kind of like how a supercomputer can process lots of information at lightning speed. It's is great for tasks like data analysis, where you need to crunch through big datasets and get results fast.

## Q3. Ingest and filter `chartevents.csv.gz`

[`chartevents.csv.gz`](https://mimic.mit.edu/docs/iv/modules/icu/chartevents/) contains all the charted data available for a patient. During their ICU stay, the primary repository of a patient's information is their electronic chart. The `itemid` variable indicates a single measurement type in the database. The `value` variable is the value measured for `itemid`. The first 10 lines of `chartevents.csv.gz` are

```{bash}
zcat < ~/mimic/icu/chartevents.csv.gz | head -10
```

[`d_items.csv.gz`](https://mimic.mit.edu/docs/iv/modules/icu/d_items/) is the dictionary for the `itemid` in `chartevents.csv.gz`.

```{bash}
zcat < ~/mimic/icu/d_items.csv.gz | head -10
```

In later exercises, we are interested in the vitals for ICU patients: heart rate (220045), mean non-invasive blood pressure (220181), systolic non-invasive blood pressure (220179), body temperature in Fahrenheit (223761), and respiratory rate (220210). Retrieve a subset of `chartevents.csv.gz` only containing these items, using the favorite method you learnt in Q2.

Document the steps and show code. Display the number of rows and the first 10 rows of the result tibble.

```{bash, eval=F}
cd ~/mimic/icu/
gzcat chartevents.csv.gz > chartevents.csv
```

```{r,eval=T}
library(arrow)
system.time({
csv_read9<-open_dataset("~/mimic/icu/chartevents.csv", format="csv")
filtered_csv_read9<-csv_read9%>%
  filter(itemid %in% c(220045, 220181, 220179, 223761, 220210)) %>%
  select(itemid, value)
})
rm(csv_read9)
filtered_csv_read9<-data.frame(filtered_csv_read9)
nrow(filtered_csv_read9)
head(filtered_csv_read9,10)


rm(filtered_csv_read9)


```

We choose the Apache Arrow to complete this task. I first wrote bash codes to decompress the .gz file. Then I use arrow::open_dataset() to read the depressed file, using filter() and select() to get the specific rows and columns (itemid and value). Finally I use nrow() and head() to get the number of rows and the first 10 rows.
